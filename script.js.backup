document.addEventListener('DOMContentLoaded', () => {
    // Canvas and Context
    const gameCanvas = document.getElementById('game-canvas');
    const ctx = gameCanvas.getContext('2d');

    // UI Elements
    const levelDisplay = document.getElementById('level-display');
    const instructionsDisplay = document.getElementById('instructions');
    const shapePaletteCanvas = document.createElement('canvas'); // Create a canvas for the palette
    const shapePaletteContainer = document.getElementById('shape-palette');
    
    // Control Buttons
    const checkSolutionBtn = document.getElementById('check-solution-btn');
    const resetLevelBtn = document.getElementById('reset-level-btn');
    const nextLevelBtn = document.getElementById('next-level-btn');
    const undoBtn = document.getElementById('undo-btn');
    
    // Seviye Seçme UI
    const levelSelectBtn = document.getElementById('level-select-btn');
    const levelDropdown = document.getElementById('level-dropdown');

    // Game State
    let currentLevelIndex = 0;
    let placedShapes = []; // To store shapes placed by the player
    let selectedShapeToRotate = null; // To allow rotation of already placed shapes (future)
    let draggedShape = null;
    let draggedShapeIndex = -1; // Index of the shape being dragged (if it's from placedShapes)
    let dragOffsetX, dragOffsetY;
    const ROTATION_STEP = 30; // Üçgenler için daha uygun bir rotasyon adımı (önceki değer: 45)
    const TARGET_AREA_OFFSET_X = 20; // Padding inside gameCanvas for the target area
    const TARGET_AREA_OFFSET_Y = 20;
    const SNAP_GRID_SIZE = 5; // Snap to 2px grid within target area (was 5)
    let currentShapeInSequenceIndex = 0;
    let availableShapes = []; // Orijinal şekillerin tam kopyaları
    let availableShapeTypes = []; // Her şekil tipinden birer örnek
    let selectedShapeIndex = 0; // Track the currently selected shape
    let highlightedShapeIndex = -1; // Index of the shape in placedShapes to highlight
    let highlightTimeoutId = null; 

    // --- Level Definitions ---
    const levels = [
        {
            levelNumber: 1,
            targetArea: { type: 'square', width: 100, height: 100, color: '#ddd' }, 
            shapeSequence: [
                { type: 'square', size: 50, color: 'lightblue', rotation: 0, vertices: [] },
                { type: 'square', size: 25, color: 'lightcoral', rotation: 0, vertices: [] },
                { type: 'rectangle', width: 50, height: 25, color: 'lightgreen', rotation: 0, vertices: [] },
                { type: 'rectangle', width: 25, height: 50, color: 'lightyellow', rotation: 0, vertices: [] },
                { type: 'square', size: 50, color: 'lavender', rotation: 0, vertices: [] },
                { type: 'square', size: 25, color: 'thistle', rotation: 0, vertices: [] }
            ],
            message: "SEVİYE 1: 100x100 kare alanı, kare ve dikdörtgenler kullanarak örüntülü şekilde kaplayın." 
        },
        {
            levelNumber: 2,
            targetArea: { type: 'rectangle', width: 200, height: 100, color: '#d8d8d8' }, 
            shapeSequence: [
                { type: 'rectangle', width: 100, height: 50, color: 'lightgreen', rotation: 0, vertices: [] },
                { type: 'rectangle', width: 50, height: 50, color: 'lightpink', rotation: 0, vertices: [] },
                { type: 'square', size: 50, color: 'lavender', rotation: 0, vertices: [] },
                { type: 'square', size: 25, color: 'lightskyblue', rotation: 0, vertices: [] },
                { type: 'rectangle', width: 25, height: 50, color: 'peachpuff', rotation: 0, vertices: [] }
            ],
            message: "SEVİYE 2: 200x100 dikdörtgen alanı, kare ve dikdörtgenlerle örüntü oluşturacak şekilde kaplayın." 
        },
        {
            levelNumber: 3,
            targetArea: { type: 'rectangle', width: 100, height: 250, color: '#e0e0e0' }, 
            shapeSequence: [
                { type: 'rectangle', width: 50, height: 100, color: 'salmon', rotation: 0, vertices: [] },
                { type: 'rectangle', width: 100, height: 50, color: 'skyblue', rotation: 0, vertices: [] },
                { type: 'square', size: 50, color: 'lightgreen', rotation: 0, vertices: [] },
                { type: 'square', size: 50, color: 'gold', rotation: 0, vertices: [] },
                { type: 'rectangle', width: 25, height: 75, color: 'plum', rotation: 0, vertices: [] }
            ],
            message: "SEVİYE 3: 100x250 dikdörtgen alanı, kare ve dikdörtgenlerle örüntü oluşturarak kaplayın." 
        },
        {
            levelNumber: 4,
            targetArea: { type: 'rectangle', width: 200, height: 250, color: '#d5d5d5' }, 
            shapeSequence: [
                { type: 'rectangle', width: 100, height: 50, color: 'purple', rotation: 0, vertices: [] },
                { type: 'rectangle', width: 50, height: 100, color: 'indigo', rotation: 0, vertices: [] },
                { type: 'rectangle', width: 50, height: 50, color: 'darkslateblue', rotation: 0, vertices: [] },
                { type: 'square', size: 50, color: 'violet', rotation: 0, vertices: [] },
                { type: 'square', size: 25, color: 'pink', rotation: 0, vertices: [] },
                { type: 'rectangle', width: 75, height: 25, color: 'lightsalmon', rotation: 0, vertices: [] }
            ],
            message: "SEVİYE 4: 200x250 dikdörtgen alanı, dikdörtgen ve kareler ile kaplayın." 
        },
        {
            levelNumber: 5,
            targetArea: { type: 'rectangle', width: 315, height: 180, color: '#cccccc' }, 
            shapeSequence: [
                { type: 'rectangle', width: 90, height: 60, color: 'teal', rotation: 0, vertices: [] },
                { type: 'rectangle', width: 60, height: 90, color: 'cyan', rotation: 0, vertices: [] },
                { type: 'square', size: 60, color: 'aqua', rotation: 0, vertices: [] },
                { type: 'square', size: 45, color: 'paleturquoise', rotation: 0, vertices: [] },
                { type: 'square', size: 45, color: 'mediumaquamarine', rotation: 0, vertices: [] },
                { type: 'rectangle', width: 45, height: 90, color: 'turquoise', rotation: 0, vertices: [] },
                { type: 'rectangle', width: 60, height: 30, color: 'crimson', rotation: 0, vertices: [] },
                { type: 'rectangle', width: 30, height: 60, color: 'firebrick', rotation: 0, vertices: [] },
                { type: 'square', size: 30, color: 'gold', rotation: 0, vertices: [] },
                { type: 'square', size: 30, color: 'orange', rotation: 0, vertices: [] }
            ],
            message: "SEVİYE 5: 315x180 dikdörtgen alanı, kare ve dikdörtgenlerle örüntü oluşturacak şekilde döşeyin." 
        },
        {
            levelNumber: 6,
            targetArea: { type: 'square', width: 200, height: 200, color: '#c0c0c0' }, 
            shapeSequence: [
                { type: 'rectangle', width: 100, height: 50, color: 'sienna', rotation: 0, vertices: [] },
                { type: 'rectangle', width: 50, height: 100, color: 'chocolate', rotation: 0, vertices: [] },
                { type: 'square', size: 50, color: 'peru', rotation: 0, vertices: [] },
                { type: 'square', size: 50, color: 'burlywood', rotation: 0, vertices: [] },
                { type: 'rectangle', width: 100, height: 25, color: 'tan', rotation: 0, vertices: [] },
                { type: 'rectangle', width: 25, height: 100, color: 'darkgoldenrod', rotation: 0, vertices: [] },
                { type: 'rectangle', width: 50, height: 50, color: 'olive', rotation: 0, vertices: [] },
                { type: 'square', size: 25, color: 'goldenrod', rotation: 0, vertices: [] }
            ],
            message: "SEVİYE 6: 200x200 kare alanı, kare ve dikdörtgenlerle döşeyerek örüntü oluşturun."
        }
        // More levels will be added here
    ];

    // --- Shape Vertex Calculation ---
    function calculateVertices(shape) {
        const { type, x, y, rotation } = shape;
        const angle = rotation * Math.PI / 180; // Convert to radians
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);
        let points = []; // Relative to shape's rotation center

        let cx, cy, w, h;

        if (type === 'square') {
            w = shape.size;
            h = shape.size;
            cx = x + w / 2;
            cy = y + h / 2;
            points = [
                { x: -w / 2, y: -h / 2 }, // Top-left
                { x:  w / 2, y: -h / 2 }, // Top-right
                { x:  w / 2, y:  h / 2 }, // Bottom-right
                { x: -w / 2, y:  h / 2 }  // Bottom-left
            ];
        } else if (type === 'rectangle') {
            w = shape.width;
            h = shape.height;
            cx = x + w / 2;
            cy = y + h / 2;
            points = [
                { x: -w / 2, y: -h / 2 },
                { x:  w / 2, y: -h / 2 },
                { x:  w / 2, y:  h / 2 },
                { x: -w / 2, y:  h / 2 }
            ];
        } else if (type === 'equilateralTriangle') {
            const side = shape.side;
            const triHeight = (Math.sqrt(3) / 2) * side;
            
            // İyileştirilmiş merkez hesabı - üçgenin ağırlık merkezi için
            cx = x + side / 2;
            cy = y + (triHeight * 2/3); // Ağırlık merkezi (daha hassas yerleşim için)
            
            // Noktalar, üçgenin ağırlık merkezine göre hesaplanıyor
            points = [
                { x: 0,        y: -triHeight * 2/3 },   // Tepe noktası (üçgenin ağırlık merkezine göre)
                { x: side / 2, y:  triHeight / 3 },     // Sağ alt köşe
                { x: -side/ 2, y:  triHeight / 3 }      // Sol alt köşe
            ];
        } else if (type === 'isoscelesRightTriangle') {
            const leg = shape.leg;
            // x,y is top-left of bounding box. Center for rotation is (x + leg/2, y + leg/2)
            cx = x + leg / 2;
            cy = y + leg / 2;
            // Vertices relative to its own center (assuming right angle at (-leg/2, -leg/2) relative to center)
            points = [
                { x: -leg / 2, y: -leg / 2 }, // Right-angle vertex
                { x:  leg / 2, y: -leg / 2 }, // End of horizontal leg
                { x: -leg / 2, y:  leg / 2 }  // End of vertical leg
            ];
        } else if (type === 'pentagon') {
            const side = shape.side;
            const R = side / (2 * Math.sin(Math.PI / 5));
            const boundingBoxWidth = 2 * R * Math.sin(2 * Math.PI / 5);
            const boundingBoxHeight = R * (1 + Math.cos(Math.PI / 5));
            cx = x + boundingBoxWidth / 2;
            cy = y + boundingBoxHeight / 2;
            for (let i = 0; i < 5; i++) {
                const angle_p = (i * 2 * Math.PI / 5) - (Math.PI / 2); // Point-up
                points.push({ 
                    x: R * Math.cos(angle_p), 
                    y: R * Math.sin(angle_p) 
                });
            }
        } else if (type === 'hexagon') {
            const side = shape.side;
            const boundingBoxWidth = 2 * side;
            const boundingBoxHeight = Math.sqrt(3) * side;
            cx = x + boundingBoxWidth / 2;
            cy = y + boundingBoxHeight / 2;
            for (let i = 0; i < 6; i++) {
                const angle_h = (i * Math.PI / 3) - (Math.PI / 6); // Flat-topped
                points.push({ 
                    x: side * Math.cos(angle_h), 
                    y: side * Math.sin(angle_h) 
                });
            }
        } else if (type === 'rhombus') {
            // Rhombus with 60/120 degree angles (side is the length of the edge)
            const side = shape.side;
            // For a rhombus made of two equilateral triangles, height is sqrt(3)*side/2 for one triangle.
            // Total height of rhombus (long diagonal) is sqrt(3)*side. Short diagonal is 'side'.
            // For vertex calculation, if x,y is top-left of bounding box:
            // Bounding box width = side, Bounding box height = sqrt(3)*side
            // Center for rotation:
            cx = x + side / 2;
            cy = y + (Math.sqrt(3) * side) / 2;
            points = [
                { x: 0,           y: -(Math.sqrt(3) * side) / 2 }, // Top vertex
                { x: side / 2,    y: 0 },                          // Right middle vertex
                { x: 0,           y: (Math.sqrt(3) * side) / 2 },  // Bottom vertex
                { x: -side / 2,   y: 0 }                           // Left middle vertex
            ];
        }
        // Add other shapes here

        shape.vertices = points.map(p => {
            const rotatedX = p.x * cosA - p.y * sinA;
            const rotatedY = p.x * sinA + p.y * cosA;
            return { x: cx + rotatedX, y: cy + rotatedY };
        });
    }


    // --- Shape Drawing Functions ---
    // All drawing functions will now take an optional rotation parameter
    function drawSquare(context, x, y, size, color, rotation = 0) {
        context.save();
        context.translate(x + size / 2, y + size / 2); // Translate to center for rotation
        context.rotate(rotation * Math.PI / 180);
        context.fillStyle = color;
        context.fillRect(-size / 2, -size / 2, size, size);
        context.strokeStyle = '#333';
        context.strokeRect(-size / 2, -size / 2, size, size);
        context.restore();
    }

    function drawRectangle(context, x, y, width, height, color, rotation = 0) {
        context.save();
        context.translate(x + width / 2, y + height / 2);
        context.rotate(rotation * Math.PI / 180);
        context.fillStyle = color;
        context.fillRect(-width / 2, -height / 2, width, height);
        context.strokeStyle = '#333';
        context.strokeRect(-width / 2, -height / 2, width, height);
        context.restore();
    }

    function drawEquilateralTriangle(context, x, y, side, color, rotation = 0) {
        const height = (Math.sqrt(3) / 2) * side;
        context.save();
        
        // İyileştirilmiş merkez hesabı - üçgenin ağırlık merkezi için
        const centerX = x + side / 2;
        const centerY = y + (height * 2/3);
        
        context.translate(centerX, centerY);
        context.rotate(rotation * Math.PI / 180);
        
        context.beginPath();
        // Ağırlık merkezinden tepe noktasına
        context.moveTo(0, -height * 2/3);
        // Ağırlık merkezinden sağ alt köşeye 
        context.lineTo(side / 2, height / 3);
        // Ağırlık merkezinden sol alt köşeye
        context.lineTo(-side / 2, height / 3);
        context.closePath();
        
        context.fillStyle = color;
        context.fill();
        context.strokeStyle = '#333';
        context.stroke();
        context.restore();
    }

    // Isosceles Right Triangle (legs are equal)
    function drawIsoscelesRightTriangle(context, x, y, leg, color, rotation = 0) {
        context.save();
        // For an isosceles right triangle, translating to the right-angle vertex might be easier for rotation.
        // Or translate to centroid: (leg/3, leg/3) from the right angle vertex.
        // Let's translate to a point that simplifies vertex calculation for now.
        // For drawing, we'll use x,y as the top-left of its bounding box if unrotated.
        context.translate(x + leg / 2, y + leg / 2); 
        context.rotate(rotation * Math.PI / 180);

        context.beginPath();
        // Assuming x,y is the top-left corner of the bounding box, and right angle is at (x,y)
        // For drawing centered, we adjust:
        context.moveTo(-leg/2, -leg/2); // Right angle vertex if centered
        context.lineTo(leg/2, -leg/2);  // Horizontal leg
        context.lineTo(-leg/2, leg/2);  // Vertical leg
        context.closePath();

        context.fillStyle = color;
        context.fill();
        context.strokeStyle = '#333';
        context.stroke();
        context.restore();
    }

    function drawPentagon(context, x, y, side, color, rotation = 0) {
        const R = side / (2 * Math.sin(Math.PI / 5)); // Outer radius
        const r = R * Math.cos(Math.PI / 5);          // Inner radius (apothem)
        
        // Bounding box for an unrotated pentagon (approximate, depends on orientation)
        // For a point-up pentagon:
        // Width = 2 * R * sin(2*PI/5) = 2 * R * sin(72 deg)
        // Height = R + r 
        const boundingBoxWidth = 2 * R * Math.sin(2 * Math.PI / 5);
        const boundingBoxHeight = R * (1 + Math.cos(Math.PI / 5));

        const centerX = x + boundingBoxWidth / 2;
        const centerY = y + boundingBoxHeight / 2;

        context.save();
        context.translate(centerX, centerY);
        context.rotate(rotation * Math.PI / 180);

        context.beginPath();
        for (let i = 0; i < 5; i++) {
            // Angle adjusted by -PI/2 to make the first point go upwards
            const angle = (i * 2 * Math.PI / 5) - (Math.PI / 2); 
            const pointX = R * Math.cos(angle);
            const pointY = R * Math.sin(angle);
            if (i === 0) {
                context.moveTo(pointX, pointY);
            } else {
                context.lineTo(pointX, pointY);
            }
        }
        context.closePath();
        
        context.fillStyle = color;
        context.fill();
        context.strokeStyle = '#333';
        context.stroke();
        context.restore();
    }

    function drawRhombus(context, x, y, side, color, rotation = 0) {
        // Rhombus with 60/120 degree angles
        const rhombusHeight = Math.sqrt(3) * side; // This is the long diagonal
        const rhombusWidth = side; // This is the short diagonal

        context.save();
        // Translate to the center of the bounding box for rotation
        context.translate(x + rhombusWidth / 2, y + rhombusHeight / 2);
        context.rotate(rotation * Math.PI / 180);

        context.beginPath();
        // Vertices relative to the center of the bounding box
        context.moveTo(0, -rhombusHeight / 2); // Top vertex
        context.lineTo(rhombusWidth / 2, 0);   // Right middle vertex
        context.lineTo(0, rhombusHeight / 2);  // Bottom vertex
        context.lineTo(-rhombusWidth / 2, 0);  // Left middle vertex
        context.closePath();

        context.fillStyle = color;
        context.fill();
        context.strokeStyle = '#333';
        context.stroke();
        context.restore();
    }

    function drawHexagon(context, x, y, side, color, rotation = 0) {
        // Bounding box for an unrotated flat-topped hexagon:
        const boundingBoxWidth = 2 * side;
        const boundingBoxHeight = Math.sqrt(3) * side;

        const centerX = x + boundingBoxWidth / 2;
        const centerY = y + boundingBoxHeight / 2;

        context.save();
        context.translate(centerX, centerY);
        context.rotate(rotation * Math.PI / 180);

        context.beginPath();
        for (let i = 0; i < 6; i++) {
            // Angle adjusted by -PI/6 to make it flat-topped
            const angle = (i * Math.PI / 3) - (Math.PI / 6); 
            const pointX = side * Math.cos(angle);
            const pointY = side * Math.sin(angle);
            if (i === 0) {
                context.moveTo(pointX, pointY);
            } else {
                context.lineTo(pointX, pointY);
            }
        }
        context.closePath();

        context.fillStyle = color;
        context.fill();
        context.strokeStyle = '#333';
        context.stroke();
        context.restore();
    }
    
    // --- Palette Shape Drawing ---
    function drawShapeInPalette() {
        shapePaletteContainer.innerHTML = ''; // Clear previous shape or content
        
        // Container stili güncelleme - arka plan ve çerçeveyi kaldır
        shapePaletteContainer.style.border = 'none';
        shapePaletteContainer.style.backgroundColor = 'transparent';
        shapePaletteContainer.style.padding = '0';
        shapePaletteContainer.style.marginTop = '15px'; // Azaltıldı: 30px -> 15px
        
        // Shape palette container'ın üst elementinin stilini kontrol et ve düzelt
        if (shapePaletteContainer.parentElement) {
            shapePaletteContainer.parentElement.style.border = 'none';
            shapePaletteContainer.parentElement.style.backgroundColor = 'transparent';
            shapePaletteContainer.parentElement.style.padding = '0';
            shapePaletteContainer.parentElement.style.marginTop = '10px'; // Azaltıldı: 25px -> 10px
        }
        
        const level = levels[currentLevelIndex];
        if (!level || !level.shapeSequence || level.shapeSequence.length === 0) {
            const noShapesMsg = document.createElement('div');
            noShapesMsg.textContent = "Şekil Yok";
            noShapesMsg.style.padding = "10px";
            noShapesMsg.style.color = "#888";
            noShapesMsg.style.textAlign = "center";
            shapePaletteContainer.appendChild(noShapesMsg);
            return;
        }

        // "Şekiller:" başlığını ekle
        const shapeTitle = document.createElement('h2');
        shapeTitle.textContent = 'Şekiller:';
        shapeTitle.style.margin = '0 0 10px 0';
        shapeTitle.style.fontSize = '1.1em';
        shapeTitle.style.color = '#555';
        shapePaletteContainer.appendChild(shapeTitle);

        // Create shape selection container
        const shapeSelectorContainer = document.createElement('div');
        shapeSelectorContainer.style.display = 'flex';
        shapeSelectorContainer.style.flexWrap = 'wrap';
        shapeSelectorContainer.style.justifyContent = 'center';
        shapeSelectorContainer.style.gap = '10px';
        shapeSelectorContainer.style.width = '100%';
        shapeSelectorContainer.style.padding = '0';

        // Create mini-canvas for each available shape
        availableShapeTypes.forEach((shape, index) => {
            const shapeBox = document.createElement('div');
            shapeBox.style.display = 'flex';
            shapeBox.style.flexDirection = 'column';
            shapeBox.style.alignItems = 'center';
            shapeBox.style.cursor = 'pointer';
            shapeBox.style.padding = '8px';
            shapeBox.style.borderRadius = '5px';
            shapeBox.style.border = index === selectedShapeIndex ? '2px solid #007bff' : '1px solid #ddd';
            shapeBox.style.backgroundColor = index === selectedShapeIndex ? '#f0f8ff' : 'white';
            shapeBox.style.transition = 'all 0.2s ease';
            shapeBox.style.width = '80px';
            shapeBox.style.margin = '0';
            shapeBox.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';
            
            // Mini canvas for shape preview
            const miniCanvas = document.createElement('canvas');
            miniCanvas.width = 60;
            miniCanvas.height = 60;
            const miniCtx = miniCanvas.getContext('2d');
            
            // Draw shape on mini canvas
            let drawX, drawY;
            
            if (shape.type === 'square') {
                const scaleFactor = Math.min(40 / shape.size, 1);
                const scaledSize = shape.size * scaleFactor;
                drawX = (miniCanvas.width - scaledSize) / 2;
                drawY = (miniCanvas.height - scaledSize) / 2;
                drawSquare(miniCtx, drawX, drawY, scaledSize, shape.color, 0);
            } else if (shape.type === 'rectangle') {
                const scaleFactor = Math.min(40 / Math.max(shape.width, shape.height), 1);
                const scaledWidth = shape.width * scaleFactor;
                const scaledHeight = shape.height * scaleFactor;
                drawX = (miniCanvas.width - scaledWidth) / 2;
                drawY = (miniCanvas.height - scaledHeight) / 2;
                drawRectangle(miniCtx, drawX, drawY, scaledWidth, scaledHeight, shape.color, 0);
            } else if (shape.type === 'equilateralTriangle') {
                const scaleFactor = Math.min(40 / shape.side, 1);
                const scaledSide = shape.side * scaleFactor;
                const triHeight = (Math.sqrt(3) / 2) * scaledSide;
                drawX = (miniCanvas.width - scaledSide) / 2;
                drawY = (miniCanvas.height - triHeight) / 2;
                drawEquilateralTriangle(miniCtx, drawX, drawY, scaledSide, shape.color, 0);
            } else if (shape.type === 'isoscelesRightTriangle') {
                const scaleFactor = Math.min(40 / shape.leg, 1);
                const scaledLeg = shape.leg * scaleFactor;
                drawX = (miniCanvas.width - scaledLeg) / 2;
                drawY = (miniCanvas.height - scaledLeg) / 2;
                drawIsoscelesRightTriangle(miniCtx, drawX, drawY, scaledLeg, shape.color, 0);
            }
            
            // Shape name label
            const shapeLabel = document.createElement('span');
            shapeLabel.style.marginTop = '5px';
            shapeLabel.style.fontSize = '12px';
            shapeLabel.style.textAlign = 'center';
            shapeLabel.style.wordWrap = 'break-word';
            shapeLabel.style.width = '100%';
            
            // Set shape name based on type
            if (shape.type === 'square') {
                shapeLabel.textContent = `Kare (${shape.size}x${shape.size})`;
            } else if (shape.type === 'rectangle') {
                shapeLabel.textContent = `Dikdörtgen (${shape.width}x${shape.height})`;
            } else if (shape.type === 'equilateralTriangle') {
                shapeLabel.textContent = `Eşkenar Üçgen (${shape.side})`;
            } else if (shape.type === 'isoscelesRightTriangle') {
                shapeLabel.textContent = `Dik Üçgen (${shape.leg})`;
            }
            
            shapeBox.onclick = () => {
                selectedShapeIndex = index;
                drawShapeInPalette();
            };
            
            shapeBox.appendChild(miniCanvas);
            shapeBox.appendChild(shapeLabel);
            shapeSelectorContainer.appendChild(shapeBox);
        });
        
        shapePaletteContainer.appendChild(shapeSelectorContainer);
    }

    // DOM yüklendikten sonra container stillerini düzelt
    function fixContainerStyles() {
        // Tüm shape-palette ilişkili elemanları düzelt
        const shapeContainer = document.getElementById('shape-palette-container');
        if (shapeContainer) {
            shapeContainer.style.border = 'none';
            shapeContainer.style.backgroundColor = 'transparent';
            shapeContainer.style.boxShadow = 'none';
            shapeContainer.style.marginTop = '15px'; // Azaltıldı: 30px -> 15px
            
            // Oyun canvas ile şekil gösterimi arasındaki mesafeyi ayarla
            const gameCanvas = document.getElementById('game-canvas');
            if (gameCanvas) {
                gameCanvas.style.marginBottom = '20px'; // Azaltıldı: 40px -> 20px
            }
            
            // Başlığı kaldır veya stil ver
            const containerTitle = shapeContainer.querySelector('h2');
            if (containerTitle) {
                containerTitle.style.display = 'none';
            }
        }
    }

    // --- Game Area Drawing ---
    function drawTargetArea(area) {
        // Set canvas dimensions based on target area, with some padding
        gameCanvas.width = area.width + TARGET_AREA_OFFSET_X * 2; 
        gameCanvas.height = area.height + TARGET_AREA_OFFSET_Y * 2; 
        
        // Canvas marginleri ayarla
        gameCanvas.style.marginBottom = '20px'; // Azaltıldı: 40px -> 20px
        
        ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height); // Clear canvas

        // Draw the target area centered
        // Target area itself is not rotated, so rotation parameter is 0 or omitted
        if (area.type === 'square') {
            drawSquare(ctx, TARGET_AREA_OFFSET_X, TARGET_AREA_OFFSET_Y, area.width, area.color, 0);
        } else if (area.type === 'rectangle') {
            drawRectangle(ctx, TARGET_AREA_OFFSET_X, TARGET_AREA_OFFSET_Y, area.width, area.height, area.color, 0);
        }
        // Add other area shapes here

        // Draw grid lines
        ctx.strokeStyle = '#e0e0e0'; // Light grey for grid lines
        ctx.lineWidth = 0.5;

        for (let gx = TARGET_AREA_OFFSET_X + SNAP_GRID_SIZE; gx < TARGET_AREA_OFFSET_X + area.width; gx += SNAP_GRID_SIZE) {
            ctx.beginPath();
            ctx.moveTo(gx, TARGET_AREA_OFFSET_Y);
            ctx.lineTo(gx, TARGET_AREA_OFFSET_Y + area.height);
            ctx.stroke();
        }
        for (let gy = TARGET_AREA_OFFSET_Y + SNAP_GRID_SIZE; gy < TARGET_AREA_OFFSET_Y + area.height; gy += SNAP_GRID_SIZE) {
            ctx.beginPath();
            ctx.moveTo(TARGET_AREA_OFFSET_X, gy);
            ctx.lineTo(TARGET_AREA_OFFSET_X + area.width, gy);
            ctx.stroke();
        }
        ctx.lineWidth = 1; // Reset line width for other drawings if necessary
    }

    function redrawCanvas() {
        const level = levels[currentLevelIndex];
        drawTargetArea(level.targetArea); // This already clears the canvas

        // Draw placed shapes
        placedShapes.forEach((shape, index) => {
            calculateVertices(shape); // Calculate vertices for placed shapes
            
            const originalStrokeStyle = ctx.strokeStyle;
            const originalLineWidth = ctx.lineWidth;

            if (index === highlightedShapeIndex) {
                ctx.strokeStyle = 'lime'; // Highlight color
                ctx.lineWidth = 2.5;
            } else {
                ctx.strokeStyle = '#333'; // Default stroke color
                ctx.lineWidth = 1;
            }

            if (shape.type === 'square') {
                drawSquare(ctx, shape.x, shape.y, shape.size, shape.color, shape.rotation);
            } else if (shape.type === 'rectangle') {
                drawRectangle(ctx, shape.x, shape.y, shape.width, shape.height, shape.color, shape.rotation);
            } else if (shape.type === 'equilateralTriangle') {
                drawEquilateralTriangle(ctx, shape.x, shape.y, shape.side, shape.color, shape.rotation);
            } else if (shape.type === 'isoscelesRightTriangle') {
                drawIsoscelesRightTriangle(ctx, shape.x, shape.y, shape.leg, shape.color, shape.rotation);
            } else if (shape.type === 'pentagon') {
                drawPentagon(ctx, shape.x, shape.y, shape.side, shape.color, shape.rotation);
            } else if (shape.type === 'hexagon') {
                drawHexagon(ctx, shape.x, shape.y, shape.side, shape.color, shape.rotation);
            }
            
            ctx.strokeStyle = originalStrokeStyle; // Reset to default
            ctx.lineWidth = originalLineWidth; // Reset to default
            // Add other shapes

            // Optional: Draw vertices for debugging
            // if (shape.vertices && shape.vertices.length > 0) {
            //     ctx.fillStyle = 'red';
            //     shape.vertices.forEach(v => ctx.fillRect(v.x - 2, v.y - 2, 4, 4));
            // }
        });

        // Draw dragged shape if any
        if (draggedShape) {
            calculateVertices(draggedShape); // Calculate vertices for dragged shape
             if (draggedShape.type === 'square') {
                drawSquare(ctx, draggedShape.x, draggedShape.y, draggedShape.size, draggedShape.color, draggedShape.rotation);
            } else if (draggedShape.type === 'rectangle') {
                drawRectangle(ctx, draggedShape.x, draggedShape.y, draggedShape.width, draggedShape.height, draggedShape.color, draggedShape.rotation);
            } else if (draggedShape.type === 'equilateralTriangle') {
                drawEquilateralTriangle(ctx, draggedShape.x, draggedShape.y, draggedShape.side, draggedShape.color, draggedShape.rotation);
            } else if (draggedShape.type === 'isoscelesRightTriangle') {
                drawIsoscelesRightTriangle(ctx, draggedShape.x, draggedShape.y, draggedShape.leg, draggedShape.color, draggedShape.rotation);
            } else if (draggedShape.type === 'pentagon') {
                drawPentagon(ctx, draggedShape.x, draggedShape.y, draggedShape.side, draggedShape.color, draggedShape.rotation);
            } else if (draggedShape.type === 'hexagon') {
                drawHexagon(ctx, draggedShape.x, draggedShape.y, draggedShape.side, draggedShape.color, draggedShape.rotation);
            }
            // Add other shapes

            // Optional: Draw vertices for debugging
            // if (draggedShape.vertices && draggedShape.vertices.length > 0) {
            //     ctx.fillStyle = 'blue';
            //     draggedShape.vertices.forEach(v => ctx.fillRect(v.x - 2, v.y - 2, 4, 4));
            // }
        }
    }

    // --- Level Initialization ---
    function loadLevel(levelIndex) {
        if (levelIndex >= levels.length) {
            instructionsDisplay.textContent = "Tebrikler! Tüm seviyeleri tamamladınız!";
            checkSolutionBtn.disabled = true;
            resetLevelBtn.disabled = true;
            nextLevelBtn.style.display = 'none';
            shapePaletteContainer.innerHTML = ''; // Clear palette
            gameCanvas.style.display = 'none'; // Hide canvas
            return;
        }

        currentLevelIndex = levelIndex;
        const level = levels[currentLevelIndex];
        placedShapes = [];
        draggedShape = null;
        
        // Mevcut seviyedeki her farklı şekil tipinden bir tane alalım
        const shapeTypeMap = new Map();
        availableShapeTypes = [];
        
        level.shapeSequence.forEach(shape => {
            const shapeKey = shape.type;
            if (!shapeTypeMap.has(shapeKey)) {
                // Bu tip şekilden henüz eklenmemişse, ekleyelim
                shapeTypeMap.set(shapeKey, JSON.parse(JSON.stringify(shape)));
                availableShapeTypes.push(JSON.parse(JSON.stringify(shape)));
            }
        });
        
        selectedShapeIndex = 0;

        levelDisplay.textContent = `Seviye: ${level.levelNumber}`;
        instructionsDisplay.textContent = level.message;
        
        gameCanvas.style.display = 'block'; // Show canvas
        gameCanvas.style.marginBottom = '20px'; // Azaltıldı: 40px -> 20px
        
        drawTargetArea(level.targetArea);
        drawShapeInPalette(); // Will use the selected shape
        redrawCanvas();
        
        // Container stillerini düzelt
        setTimeout(fixContainerStyles, 50);

        checkSolutionBtn.disabled = false;
        resetLevelBtn.disabled = false;
        nextLevelBtn.style.display = 'none';
        undoBtn.disabled = placedShapes.length === 0;
    }

    // --- Event Listeners ---
    gameCanvas.addEventListener('mousedown', (e) => {
        const rect = gameCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Önce mevcut bir yerleştirilmiş şeklin üzerine tıklanıp tıklanmadığını kontrol et
        for (let i = placedShapes.length - 1; i >= 0; i--) {
            const shape = placedShapes[i];
            
            // Fare bu şeklin içinde mi kontrol et
            if (isPointInShape(mouseX, mouseY, shape)) {
                // Şekli sürüklemek için placedShapes'den kaldır
                draggedShape = JSON.parse(JSON.stringify(shape));
                draggedShapeIndex = i;
                
                // Sürükleme ofsetini hesapla
                if (shape.type === 'square') {
                    dragOffsetX = mouseX - shape.x;
                    dragOffsetY = mouseY - shape.y;
                } else if (shape.type === 'rectangle') {
                    dragOffsetX = mouseX - shape.x;
                    dragOffsetY = mouseY - shape.y;
                } else if (shape.type === 'equilateralTriangle') {
                    dragOffsetX = mouseX - shape.x;
                    dragOffsetY = mouseY - shape.y;
                } else if (shape.type === 'isoscelesRightTriangle') {
                    dragOffsetX = mouseX - shape.x;
                    dragOffsetY = mouseY - shape.y;
                } else {
                    // Diğer şekiller için fallback
                    dragOffsetX = mouseX - shape.x;
                    dragOffsetY = mouseY - shape.y;
                }
                
                // Şekli geçici olarak placedShapes'den kaldır
                placedShapes.splice(i, 1);
                
                // Mouse hareketlerini izlemeye başla
                document.addEventListener('mousemove', mouseMove);
                document.addEventListener('mouseup', mouseUp);
                
                redrawCanvas();
                
                // Etkinlik yayılmasını engelle
                e.preventDefault();
                e.stopPropagation();
                return;
            }
        }
    });

    shapePaletteCanvas.addEventListener('mousedown', (e) => {
        const level = levels[currentLevelIndex];
        if (!level || !availableShapeTypes || availableShapeTypes.length === 0) {
            return; // Sürüklenecek şekil yok
        }

        const shapeToDrag = availableShapeTypes[selectedShapeIndex];
        draggedShape = JSON.parse(JSON.stringify(shapeToDrag)); // Deep copy
        draggedShapeIndex = -1; // Bu, yerleştirilmiş şekillerden olmayan yeni bir şekil olduğunu gösterir
        
        const paletteRect = shapePaletteCanvas.getBoundingClientRect();
        const gameCanvasRect = gameCanvas.getBoundingClientRect();

        // Ofset hesaplaması için palette'deki şeklin görsel sol üst köşesini belirle
        let paletteShapeDrawX, paletteShapeDrawY;
        let shapeLogicalWidth, shapeLogicalHeight;

        // Şekil türüne göre mantıksal boyut hesapla
        if (draggedShape.type === 'square') {
            shapeLogicalWidth = draggedShape.size;
            shapeLogicalHeight = draggedShape.size;
            paletteShapeDrawX = (shapePaletteCanvas.width - shapeLogicalWidth) / 2;
            paletteShapeDrawY = (shapePaletteCanvas.height - shapeLogicalHeight) / 2;
        } else if (draggedShape.type === 'rectangle') {
            shapeLogicalWidth = draggedShape.width;
            shapeLogicalHeight = draggedShape.height;
            paletteShapeDrawX = (shapePaletteCanvas.width - shapeLogicalWidth) / 2;
            paletteShapeDrawY = (shapePaletteCanvas.height - shapeLogicalHeight) / 2;
        } else if (draggedShape.type === 'equilateralTriangle') {
            shapeLogicalWidth = draggedShape.side;
            shapeLogicalHeight = (Math.sqrt(3) / 2) * draggedShape.side;
            paletteShapeDrawX = (shapePaletteCanvas.width - shapeLogicalWidth) / 2;
            paletteShapeDrawY = (shapePaletteCanvas.height - shapeLogicalHeight) / 2;
        } else if (draggedShape.type === 'isoscelesRightTriangle') {
            shapeLogicalWidth = draggedShape.leg;
            shapeLogicalHeight = draggedShape.leg;
            paletteShapeDrawX = (shapePaletteCanvas.width - shapeLogicalWidth) / 2;
            paletteShapeDrawY = (shapePaletteCanvas.height - shapeLogicalHeight) / 2;
        } else if (draggedShape.type === 'pentagon') {
            const R_p = draggedShape.side / (2 * Math.sin(Math.PI / 5));
            shapeLogicalWidth = 2 * R_p * Math.sin(2 * Math.PI / 5);
            shapeLogicalHeight = R_p * (1 + Math.cos(Math.PI / 5));
            paletteShapeDrawX = (shapePaletteCanvas.width - shapeLogicalWidth) / 2;
            paletteShapeDrawY = (shapePaletteCanvas.height - shapeLogicalHeight) / 2;
        } else if (draggedShape.type === 'hexagon') {
            shapeLogicalWidth = 2 * draggedShape.side;
            shapeLogicalHeight = Math.sqrt(3) * draggedShape.side;
            paletteShapeDrawX = (shapePaletteCanvas.width - shapeLogicalWidth) / 2;
            paletteShapeDrawY = (shapePaletteCanvas.height - shapeLogicalHeight) / 2;
        } else { // Fallback
            shapeLogicalWidth = 50; 
            shapeLogicalHeight = 50;
            paletteShapeDrawX = (shapePaletteCanvas.width - shapeLogicalWidth) / 2;
            paletteShapeDrawY = (shapePaletteCanvas.height - shapeLogicalHeight) / 2;
        }

        // Palette'deki şeklin görsel sol üst köşesinden tıklama noktasına kadar olan ofset
        dragOffsetX = (e.clientX - paletteRect.left) - paletteShapeDrawX;
        dragOffsetY = (e.clientY - paletteRect.top) - paletteShapeDrawY;

        // Oyun tuvalinde başlangıç pozisyonu: tuvaldeki fare pozisyonu eksi hesaplanan ofset
        draggedShape.x = (e.clientX - gameCanvasRect.left) - dragOffsetX;
        draggedShape.y = (e.clientY - gameCanvasRect.top) - dragOffsetY;
        
        // Mouse hareketlerini izlemeye başla
        document.addEventListener('mousemove', mouseMove);
        document.addEventListener('mouseup', mouseUp);
        
        redrawCanvas();
        
        // Etkinlik yayılmasını engelle
        e.preventDefault();
        e.stopPropagation();
    });

    // Mouse hareketi için global işleyici
    function mouseMove(e) {
        if (!draggedShape) return;

        const gameCanvasRect = gameCanvas.getBoundingClientRect();
        
        // Şeklin sol üst köşesini fare konumuna ve ilk sürükleme offsetine göre güncelle
        draggedShape.x = (e.clientX - gameCanvasRect.left) - dragOffsetX;
        draggedShape.y = (e.clientY - gameCanvasRect.top) - dragOffsetY;
        
        redrawCanvas();
        
        // Etkinlik yayılmasını engelle
        e.preventDefault();
    }

    // Mouse bırakma için global işleyici
    function mouseUp(e) {
        if (!draggedShape) return;

        const gameCanvasRect = gameCanvas.getBoundingClientRect();
        
        // Fare oyun tuvalinin üzerinde mi kontrol et
        if (
            e.clientX >= gameCanvasRect.left && 
            e.clientX <= gameCanvasRect.right && 
            e.clientY >= gameCanvasRect.top && 
            e.clientY <= gameCanvasRect.bottom
        ) {
            // Şeklin son pozisyonunu ayarla
            draggedShape.x = (e.clientX - gameCanvasRect.left) - dragOffsetX;
            draggedShape.y = (e.clientY - gameCanvasRect.top) - dragOffsetY;
            
            const level = levels[currentLevelIndex];
            const targetArea = level.targetArea;

            // Şeklin sol üst köşesini (x,y) ızgaraya yapıştır, hedef alanın orijinine göre
            draggedShape.x = TARGET_AREA_OFFSET_X + Math.round((draggedShape.x - TARGET_AREA_OFFSET_X) / SNAP_GRID_SIZE) * SNAP_GRID_SIZE;
            draggedShape.y = TARGET_AREA_OFFSET_Y + Math.round((draggedShape.y - TARGET_AREA_OFFSET_Y) / SNAP_GRID_SIZE) * SNAP_GRID_SIZE;
            
            calculateVertices(draggedShape); // Yapıştırma pozisyonundan sonra köşeleri yeniden hesapla

            let allVerticesInBounds = true;
            if (draggedShape.vertices && draggedShape.vertices.length > 0) {
                for (const vertex of draggedShape.vertices) {
                    if (vertex.x < TARGET_AREA_OFFSET_X - 0.1 || 
                        vertex.x > TARGET_AREA_OFFSET_X + targetArea.width + 0.1 ||
                        vertex.y < TARGET_AREA_OFFSET_Y - 0.1 ||
                        vertex.y > TARGET_AREA_OFFSET_Y + targetArea.height + 0.1) {
                        allVerticesInBounds = false;
                        break;
                    }
                }
            } else {
                allVerticesInBounds = false; // calculateVertices doğruysa olmamalı
            }

            if (allVerticesInBounds) {
                // Şeklin mevcut şekillerle çakışıp çakışmayacağını kontrol et
                let hasOverlap = false;
                
                // Önce, mevcut pozisyonda yerleştirmeyi dene
                for (const placedShape of placedShapes) {
                    if (checkShapesOverlap(draggedShape, placedShape)) {
                        hasOverlap = true;
                        break;
                    }
                }
                
                // Çakışma varsa, yakındaki pozisyonları dene
                if (hasOverlap) {
                    const originalX = draggedShape.x;
                    const originalY = draggedShape.y;
                    const directions = [
                        { dx: SNAP_GRID_SIZE, dy: 0 },       // sağ
                        { dx: 0, dy: SNAP_GRID_SIZE },       // aşağı
                        { dx: -SNAP_GRID_SIZE, dy: 0 },      // sol
                        { dx: 0, dy: -SNAP_GRID_SIZE },      // yukarı
                        { dx: SNAP_GRID_SIZE, dy: SNAP_GRID_SIZE },    // sağ-aşağı
                        { dx: -SNAP_GRID_SIZE, dy: SNAP_GRID_SIZE },   // sol-aşağı
                        { dx: -SNAP_GRID_SIZE, dy: -SNAP_GRID_SIZE },  // sol-yukarı
                        { dx: SNAP_GRID_SIZE, dy: -SNAP_GRID_SIZE }    // sağ-yukarı
                    ];
                    
                    // Makul bir aralıkta alternatifler dene (3 ızgara hücresi)
                    const MAX_ATTEMPTS = 3;
                    let foundValidPosition = false;
                    
                    for (let attempt = 1; attempt <= MAX_ATTEMPTS; attempt++) {
                        for (const dir of directions) {
                            draggedShape.x = originalX + dir.dx * attempt;
                            draggedShape.y = originalY + dir.dy * attempt;
                            
                            // Bu pozisyon için köşeleri yeniden hesapla
                            calculateVertices(draggedShape);
                            
                            // Önce sınırları kontrol et
                            let stillInBounds = true;
                            for (const vertex of draggedShape.vertices) {
                                if (vertex.x < TARGET_AREA_OFFSET_X - 0.1 || 
                                    vertex.x > TARGET_AREA_OFFSET_X + targetArea.width + 0.1 ||
                                    vertex.y < TARGET_AREA_OFFSET_Y - 0.1 || 
                                    vertex.y > TARGET_AREA_OFFSET_Y + targetArea.height + 0.1) {
                                    stillInBounds = false;
                                    break;
                                }
                            }
                            
                            if (!stillInBounds) continue;
                            
                            // Mevcut şekillerle çakışma kontrol et
                            let currentOverlap = false;
                            for (const placedShape of placedShapes) {
                                if (checkShapesOverlap(draggedShape, placedShape)) {
                                    currentOverlap = true;
                                    break;
                                }
                            }
                            
                            if (!currentOverlap) {
                                foundValidPosition = true;
                                hasOverlap = false;
                                break;
                            }
                        }
                        
                        if (foundValidPosition) break;
                    }
                    
                    // Hala bir pozisyon bulamadıysak, orijinal pozisyona geri dön
                    if (hasOverlap) {
                        draggedShape.x = originalX;
                        draggedShape.y = originalY;
                        calculateVertices(draggedShape);
                    }
                }
                
                const newShape = JSON.parse(JSON.stringify(draggedShape));
                placedShapes.push(newShape);
            }
        }
            
        // Event dinleyicileri temizle
        document.removeEventListener('mousemove', mouseMove);
        document.removeEventListener('mouseup', mouseUp);
        
        draggedShape = null;
        draggedShapeIndex = -1;
        redrawCanvas();
        undoBtn.disabled = placedShapes.length === 0;
        
        // Etkinlik yayılmasını engelle
        e.preventDefault();
    });
    
    // Döndürme tuşu olayını geliştirme (daha net kullanıcı geribildirimi)
    window.addEventListener('keydown', (e) => {
        if (e.key === 'r' || e.key === 'R') {
            if (draggedShape) {
                // Şekil tipine göre farklı rotasyon adımları
                if (draggedShape.type === 'equilateralTriangle') {
                    // Eşkenar üçgenler için 60 derecelik rotasyon adımı (simetri nedeniyle)
                    draggedShape.rotation = (draggedShape.rotation + 60) % 360;
                } else {
                    // Diğer şekiller için standart rotasyon adımı
                    draggedShape.rotation = (draggedShape.rotation + ROTATION_STEP) % 360;
                }
                
                // Ses veya görsel geri bildirim eklenebilir
                // Örneğin geçici bir renk değişimi:
                const originalColor = draggedShape.color;
                draggedShape.color = 'lightyellow'; // Geçici parlak renk
                redrawCanvas();
                
                // Kısa süre sonra orijinal renge dön
                setTimeout(() => {
                    if (draggedShape) { // Hala sürüklenen şekil varsa
                        draggedShape.color = originalColor;
                        redrawCanvas();
                    }
                }, 100);
            } 
        }
    });

    gameCanvas.addEventListener('mouseleave', (e) => {
        // If mouse leaves canvas while dragging, cancel drag or drop it
        if (draggedShape) {
            // For now, just cancel the drag
            draggedShape = null;
            redrawCanvas();
        }
    });

    resetLevelBtn.addEventListener('click', () => {
        loadLevel(currentLevelIndex);
    });

    undoBtn.addEventListener('click', () => {
        if (placedShapes.length > 0) {
            placedShapes.pop();
            if (currentShapeInSequenceIndex > 0) { // Ensure we don't go below 0
                currentShapeInSequenceIndex--;
            }
            drawShapeInPalette();
            redrawCanvas();
            
            // Re-enable check solution button if it was disabled due to a correct solution
            // and reset instructions if they showed a success message.
            const level = levels[currentLevelIndex];
            if (instructionsDisplay.textContent.startsWith("Tebrikler!")) {
                 instructionsDisplay.textContent = level.message;
            }
            checkSolutionBtn.disabled = false; 
            nextLevelBtn.style.display = 'none';
        }
        undoBtn.disabled = placedShapes.length === 0;
    });

    // --- Collision Detection / Solution Checking (SAT - Separating Axis Theorem) ---

    function getAxes(vertices) {
        const axes = [];
        for (let i = 0; i < vertices.length; i++) {
            const p1 = vertices[i];
            const p2 = vertices[(i + 1) % vertices.length]; // Next vertex, wraps around
            const edge = { x: p2.x - p1.x, y: p2.y - p1.y };
            // Perpendicular axis (normal)
            const normal = { x: -edge.y, y: edge.x };
            axes.push(normalizeVector(normal));
        }
        return axes;
    }

    function normalizeVector(vector) {
        const magnitude = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
        if (magnitude === 0) return { x: 0, y: 0 }; // Avoid division by zero
        return { x: vector.x / magnitude, y: vector.y / magnitude };
    }

    function projectShapeOntoAxis(vertices, axis) {
        let min = Infinity;
        let max = -Infinity;
        for (const vertex of vertices) {
            const projection = vertex.x * axis.x + vertex.y * axis.y; // Dot product
            min = Math.min(min, projection);
            max = Math.max(max, projection);
        }
        return { min, max };
    }

    const EPSILON = 1.5; // Toleransı artır (eski değer: 1.0)

    function doProjectionsOverlap(projection1, projection2) {
        // Check if projection1 is to the left of projection2 OR projection2 is to the left of projection1
        // with a tolerance.
        // If (projection1.max is less than or equal to projection2.min + EPSILON) OR
        //    (projection2.max is less than or equal to projection1.min + EPSILON)
        // then they do NOT overlap (or only touch within tolerance).
        // So, they DO overlap if NEITHER of these is true.
        
        // Original logic: return projection1.max > projection2.min && projection2.max > projection1.min;
        // New logic with epsilon:
        // Overlap exists if projection1's max is greater than projection2's min (by more than epsilon)
        // AND projection2's max is greater than projection1's min (by more than epsilon).
        return projection1.max - projection2.min > EPSILON && 
               projection2.max - projection1.min > EPSILON;
    }

    function checkShapesOverlap(shape1, shape2) {
        if (!shape1.vertices || !shape2.vertices || shape1.vertices.length < 3 || shape2.vertices.length < 3) {
            return false; // Cannot check overlap if vertices are not defined or not a polygon
        }
        
        // Üçgenler için özel durum (görüntüden anlaşıldığı kadarıyla üçgenler arası çarpışmalar sorun oluyor)
        if (shape1.type === 'equilateralTriangle' && shape2.type === 'equilateralTriangle') {
            // Üçgenler arası mesafe kontrolü - merkezleri arasındaki mesafe
            const dx = shape1.x - shape2.x;
            const dy = shape1.y - shape2.y;
            const centerDistance = Math.sqrt(dx * dx + dy * dy);
            
            // Üçgenler arasında minimum mesafe (üçgenin yüksekliği kullanılarak)
            const triHeight1 = (Math.sqrt(3) / 2) * shape1.side;
            const triHeight2 = (Math.sqrt(3) / 2) * shape2.side;
            const minDistance = Math.max(triHeight1, triHeight2) * 0.8; // Biraz tolerans ile
            
            // Eğer merkezler arasındaki mesafe belli bir değerin altındaysa, çakışma var kabul edelim
            if (centerDistance < minDistance) {
                return true; // Üçgenler çakışıyor
            }
            return false; // Üçgenler çakışmıyor
        }
        
        // Diğer şekiller için standart kontrolü kullan
        const axes1 = getAxes(shape1.vertices);
        const axes2 = getAxes(shape2.vertices);

        // Test axes of first polygon
        for (const axis of axes1) {
            const projection1 = projectShapeOntoAxis(shape1.vertices, axis);
            const projection2 = projectShapeOntoAxis(shape2.vertices, axis);
            if (!doProjectionsOverlap(projection1, projection2)) {
                return false; // Found a separating axis
            }
        }

        // Test axes of second polygon
        for (const axis of axes2) {
            const projection1 = projectShapeOntoAxis(shape1.vertices, axis);
            const projection2 = projectShapeOntoAxis(shape2.vertices, axis);
            if (!doProjectionsOverlap(projection1, projection2)) {
                return false; // Found a separating axis
            }
        }
        return true; // No separating axis found, polygons overlap
    }
    
    function getShapeArea(shape) {
        if (!shape.vertices || shape.vertices.length < 3) return 0;
        // Using Shoelace formula for polygon area
        let area = 0;
        for (let i = 0; i < shape.vertices.length; i++) {
            const p1 = shape.vertices[i];
            const p2 = shape.vertices[(i + 1) % shape.vertices.length];
            area += (p1.x * p2.y - p2.x * p1.y);
        }
        return Math.abs(area / 2);
    }


    checkSolutionBtn.addEventListener('click', () => {
        const level = levels[currentLevelIndex];
        const target = level.targetArea;
        let isCorrect = true;
        let message = "";

        if (placedShapes.length === 0) {
            isCorrect = false;
            message = "Hiç şekil yerleştirmediniz!";
        } else {
            // 1. Check for overlaps between placed shapes
            for (let i = 0; i < placedShapes.length; i++) {
                for (let j = i + 1; j < placedShapes.length; j++) {
                    if (checkShapesOverlap(placedShapes[i], placedShapes[j])) {
                        isCorrect = false;
                        message = "Şekiller üst üste biniyor!";
                        break;
                    }
                }
                if (!isCorrect) break;
            }

            // 2. Ensure all shapes are within bounds (already mostly handled on drop, but good to re-verify)
            if (isCorrect) {
                for (const shape of placedShapes) {
                    if (!shape.vertices || shape.vertices.length === 0) calculateVertices(shape); // Ensure vertices are calculated
                    for (const vertex of shape.vertices) {
                        if (vertex.x < TARGET_AREA_OFFSET_X - 0.5 || // Increased tolerance slightly
                            vertex.x > TARGET_AREA_OFFSET_X + target.width + 0.5 ||
                            vertex.y < TARGET_AREA_OFFSET_Y - 0.5 ||
                            vertex.y > TARGET_AREA_OFFSET_Y + target.height + 0.5) {
                            isCorrect = false;
                            message = "Bir veya daha fazla şekil hedef alanın dışında!";
                            break;
                        }
                    }
                    if (!isCorrect) break;
                }
            }

            // 3. Simplified Area Check (Total area of placed shapes vs target area)
            // This is a necessary but not sufficient condition for full coverage without gaps.
            if (isCorrect) {
                const targetAreaActual = target.width * target.height;
                let totalPlacedArea = 0;
                placedShapes.forEach(shape => {
                    totalPlacedArea += getShapeArea(shape);
                });

                // Allow a small tolerance for floating point inaccuracies in area calculation
                const areaTolerance = 1; // e.g., 1 square pixel
                if (Math.abs(totalPlacedArea - targetAreaActual) > areaTolerance) {
                    isCorrect = false;
                    if (totalPlacedArea < targetAreaActual) {
                        message = `Alan tam olarak kaplanmadı. Kaplanan alan: ${totalPlacedArea.toFixed(0)}, Hedef alan: ${targetAreaActual.toFixed(0)}`;
                    } else {
                        message = `Alan gerekenden fazla kaplandı. Kaplanan alan: ${totalPlacedArea.toFixed(0)}, Hedef alan: ${targetAreaActual.toFixed(0)}`;
                    }
                }
            }
            
            // 4. Örüntü kontrolü - aynı tipteki şekillerin dağılımını kontrol et
            if (isCorrect) {
                // Şekil tiplerini grupla
                const shapeTypeGroups = {};
                placedShapes.forEach(shape => {
                    if (!shapeTypeGroups[shape.type]) {
                        shapeTypeGroups[shape.type] = [];
                    }
                    shapeTypeGroups[shape.type].push(shape);
                });
                
                // Her bir şekil tipi için örüntü kontrolü
                let hasValidPattern = true;
                
                // 1. seviye için özel kontrol - üçgen kullanımı zorunlu
                if (currentLevelIndex === 0) {
                    // 1. seviyede mutlaka üçgen(ler) kullanılmalı
                    if (!shapeTypeGroups['isoscelesRightTriangle'] || shapeTypeGroups['isoscelesRightTriangle'].length < 2) {
                        hasValidPattern = false;
                        message = "Örüntü oluşturmak için en az 2 dik üçgen kullanmalısınız!";
                    }
                }
                // Diğer seviyeler için genel kontrol
                else {
                    // En az 2 farklı şekil tipi kullanılmış mı kontrol et
                    if (Object.keys(shapeTypeGroups).length < 2) {
                        hasValidPattern = false;
                        message = "Örüntü oluşturmak için en az 2 farklı tipte şekil kullanmalısınız!";
                    }
                    
                    // Her tipten en az 2 şekil kullanılmış mı kontrol et
                    if (hasValidPattern) {
                        for (const type in shapeTypeGroups) {
                            if (shapeTypeGroups[type].length < 2) {
                                hasValidPattern = false;
                                message = `Örüntü oluşturmak için her tipten en az 2 şekil kullanmalısınız! (${type} şeklinden sadece 1 adet var)`;
                                break;
                            }
                        }
                    }
                }
                
                // Şekillerin düzenli dağılımını kontrol et
                // Basit bir örüntü kontrolü: aynı tipteki şekiller birbirine yakın olmamalı
                if (hasValidPattern) {
                    for (const type in shapeTypeGroups) {
                        const shapes = shapeTypeGroups[type];
                        if (shapes.length >= 3) {
                            // Şekillerin merkez konumlarını hesapla
                            const positions = shapes.map(shape => ({
                                x: shape.x + (shape.width || shape.size || shape.leg || shape.side) / 2,
                                y: shape.y + (shape.height || shape.size || shape.leg || (Math.sqrt(3) / 2) * shape.side) / 2
                            }));
                            
                            // Şekillerin dağılımını kontrol et
                            let isDistributed = true;
                            for (let i = 0; i < positions.length; i++) {
                                let closeSameTypeCount = 0;
                                for (let j = 0; j < positions.length; j++) {
                                    if (i !== j) {
                                        const dx = positions[i].x - positions[j].x;
                                        const dy = positions[i].y - positions[j].y;
                                        const distance = Math.sqrt(dx * dx + dy * dy);
                                        
                                        // Aynı tipteki şekiller çok yakınsa
                                        // Level 1 için daha küçük bir eşik değeri kullan
                                        const distanceThreshold = currentLevelIndex === 0 ? 30 : 60;
                                        if (distance < distanceThreshold) {
                                            closeSameTypeCount++;
                                        }
                                    }
                                }
                                
                                if (closeSameTypeCount > 2) {
                                    isDistributed = false;
                                    break;
                                }
                            }
                            
                            if (!isDistributed) {
                                hasValidPattern = false;
                                message = `Aynı tipteki şekiller daha iyi dağıtılmalı! Örüntü için şekilleri daha dengeli yerleştirin.`;
                                break;
                            }
                        }
                    }
                }
                
                if (!hasValidPattern) {
                    isCorrect = false;
                }
            }
        }

        if (isCorrect) {
            instructionsDisplay.textContent = "Tebrikler! Doğru çözüm ve güzel bir örüntü!";
            nextLevelBtn.style.display = 'inline-block';
            checkSolutionBtn.disabled = true;
        } else {
            instructionsDisplay.textContent = message || "Tam olarak kaplanmadı veya hatalar var. Tekrar deneyin.";
        }
    });

    nextLevelBtn.addEventListener('click', () => {
        loadLevel(currentLevelIndex + 1);
    });
    
    // Seviye Seçme İşlevsellikleri
    // Dropdown menüyü oluşturan fonksiyon
    function createLevelDropdown() {
        levelDropdown.innerHTML = '';
        levels.forEach((level, index) => {
            const levelButton = document.createElement('button');
            levelButton.textContent = `Seviye ${level.levelNumber}`;
            levelButton.dataset.levelIndex = index;
            levelButton.addEventListener('click', () => {
                // Seviye değiştirildiğinde doğrulama yapılmasını isteyelim
                if (placedShapes.length > 0) {
                    if (!confirm("Yerleştirdiğiniz şekiller kaybolacak. Devam etmek istiyor musunuz?")) {
                        return;
                    }
                }
                loadLevel(index);
                toggleLevelDropdown();
            });
            levelDropdown.appendChild(levelButton);
        });
    }
    
    // Dropdown menüyü aç/kapat
    function toggleLevelDropdown() {
        levelDropdown.classList.toggle('show');
    }
    
    // Dropdown dışına tıklandığında menüyü kapat
    window.addEventListener('click', (event) => {
        if (!event.target.matches('#level-select-btn') && levelDropdown.classList.contains('show')) {
            levelDropdown.classList.remove('show');
        }
    });
    
    // Seviye seçme butonuna tıklandığında
    levelSelectBtn.addEventListener('click', () => {
        createLevelDropdown();
        toggleLevelDropdown();
    });

    // --- Initialize Game ---
    loadLevel(currentLevelIndex);
});

// Yardımcı fonksiyon: Bir noktanın şeklin içinde olup olmadığını kontrol eder
function isPointInShape(x, y, shape) {
    if (!shape.vertices || shape.vertices.length === 0) {
        calculateVertices(shape); // Ensure vertices are calculated
    }
    
    // Basit şekiller için kolay kontrol
    if (shape.type === 'square') {
        return (x >= shape.x && x <= shape.x + shape.size &&
                y >= shape.y && y <= shape.y + shape.size);
    } else if (shape.type === 'rectangle') {
        return (x >= shape.x && x <= shape.x + shape.width &&
                y >= shape.y && y <= shape.y + shape.height);
    } 
    
    // Diğer şekiller için içinde bulunma kontrolü
    // Yatay ışın algoritması kullanılır
    const vertices = shape.vertices;
    let inside = false;
    
    for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        const xi = vertices[i].x, yi = vertices[i].y;
        const xj = vertices[j].x, yj = vertices[j].y;
        
        const intersect = ((yi > y) != (yj > y)) &&
            (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            
        if (intersect) inside = !inside;
    }
    
    return inside;
}
